<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_22) on Mon Dec 20 20:40:15 CET 2010 -->
<TITLE>
AlignerTrainer (Mary Java API)
</TITLE>

<META NAME="date" CONTENT="2010-12-20">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="AlignerTrainer (Mary Java API)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/AlignerTrainer.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../marytts/fst/FST.html" title="class in marytts.fst"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?marytts/fst/AlignerTrainer.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="AlignerTrainer.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
marytts.fst</FONT>
<BR>
Class AlignerTrainer</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><B>marytts.fst.AlignerTrainer</B>
</PRE>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../marytts/tools/newlanguage/LTSTrainer.html" title="class in marytts.tools.newlanguage">LTSTrainer</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>AlignerTrainer</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
This trains an alignment model between Strings. Applications are for example 
 letter-to-sound rule training (see LTSTrainer) or transducer 
 construction/minimization.
 
 The basic idea is to perform a levenshtein search for the cheapest path and 
 read off an alignment from that. The costs used in the distance computation
 are not uniform but estimated in an iterative process, according to -log of
 the relative frequencies of the respective operations in the previous iteration. 
 Perform several iterations (e.g. 4) of aligning in order to get stable 
 estimates of the costs (and a good alignment in turn).
 
 The algorithm, in its essence, is implemented after a description of levenshtein
 distance as it can be found in Wikipedia (see the linked revision):
 
 http://en.wikipedia.org/w/index.php?title=Levenshtein_distance&oldid=349201802#Computing_Levenshtein_distance
 
 consider the costs used in the pseudo-code:
 
       d[i, j] := minimum
                  (
                    d[i-1, j] + 1,  // deletion
                    d[i, j-1] + 1,  // insertion
                    d[i-1, j-1] + 1 // substitution
                  )

 In our implementation there are only two operations, corresponding to deletion and
 insertion. So, if you look at the matrices in the wiki article, you can only go 
 down and to the right, but not diagonal. Second, the costs are not 1 but set
 as explained in the following (note that this is a heuristic that seems to 
 work fine but _not_ a derived EM-algorithm).
 
 "insertion" menas in our case, to insert something for (dependent on) the 
 current input symbol. The cost for this operation is lower if the two symbols
 were already aligned in the preceding iteration, they are set to
 -log P(output-symbol|"insertion",input-symbol)
 
 "deletion" means in our case to go to the next input symbol. If a deletion
 operation is performed without an preceding insertion operation (i.e. two 
 subsequent deletion operations) this is called a "skip" and will produce 
 costs, going to the next symbol after an insertion is free (this is to avoid
 unaligned input symbols). The skip costs are estimated from the preceding
 iteration and set to -log P(skip|"deletion").
 
 In addition, I made the following optimization, described in Wikipedia:
 
   We can adapt the algorithm to use less space, O(m) instead of O(mn), since 
   it only requires that the previous row and current row be stored at any 
   one time.
   
 therefore the three arrays for all information and the swapping statements 
 in the align method. (note that what are rows in Wikipedia are columns here)
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>benjaminroth</DD>
</DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Set&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../marytts/fst/AlignerTrainer.html#graphemeSet">graphemeSet</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.List&lt;java.lang.String[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../marytts/fst/AlignerTrainer.html#inSplit">inSplit</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;org.apache.log4j.Logger</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../marytts/fst/AlignerTrainer.html#logger">logger</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.List&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../marytts/fst/AlignerTrainer.html#optInfo">optInfo</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.List&lt;java.lang.String[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../marytts/fst/AlignerTrainer.html#outSplit">outSplit</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../marytts/fst/AlignerTrainer.html#AlignerTrainer()">AlignerTrainer</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New AlignerTrainer for pairs of different symbol sets with no optional info.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../marytts/fst/AlignerTrainer.html#AlignerTrainer(boolean, boolean)">AlignerTrainer</A></B>(boolean&nbsp;inIsOutAlphabet,
               boolean&nbsp;hasOptInfo)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../marytts/fst/AlignerTrainer.html#addAlreadySplit(java.util.List, java.util.List)">addAlreadySplit</A></B>(java.util.List&lt;java.lang.String&gt;&nbsp;inStr,
                java.util.List&lt;java.lang.String&gt;&nbsp;outStr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../marytts/fst/AlignerTrainer.html#addAlreadySplit(java.util.List, java.util.List, java.lang.String)">addAlreadySplit</A></B>(java.util.List&lt;java.lang.String&gt;&nbsp;inStr,
                java.util.List&lt;java.lang.String&gt;&nbsp;outStr,
                java.lang.String&nbsp;optionalInfo)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../marytts/fst/AlignerTrainer.html#addAlreadySplit(java.lang.String[], java.lang.String[])">addAlreadySplit</A></B>(java.lang.String[]&nbsp;inStr,
                java.lang.String[]&nbsp;outStr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../marytts/fst/AlignerTrainer.html#addAlreadySplit(java.lang.String[], java.lang.String[], java.lang.String)">addAlreadySplit</A></B>(java.lang.String[]&nbsp;inStr,
                java.lang.String[]&nbsp;outStr,
                java.lang.String&nbsp;optionalInfo)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../marytts/fst/AlignerTrainer.html#align(java.lang.String[], java.lang.String[])">align</A></B>(java.lang.String[]&nbsp;istr,
      java.lang.String[]&nbsp;ostr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This computes the alignment that has the lowest distance between two
 Strings.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../marytts/fst/AlignerTrainer.html#alignIteration()">alignIteration</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;One iteration of alignment, using adapted Levenshtein distance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../marytts/fst/StringPair.html" title="class in marytts.fst">StringPair</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../marytts/fst/AlignerTrainer.html#getAlignment(int)">getAlignment</A></B>(int&nbsp;entryNr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gets an alignment of the graphemes to the phones of an entry.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../marytts/fst/AlignerTrainer.html#getAlignmentString(int)">getAlignmentString</A></B>(int&nbsp;entryNr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../marytts/fst/StringPair.html" title="class in marytts.fst">StringPair</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../marytts/fst/AlignerTrainer.html#getInfoAlignment(int)">getInfoAlignment</A></B>(int&nbsp;entryNr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gets an alignment of the graphemes to the phones of an entry.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../marytts/fst/AlignerTrainer.html#getInputSyms()">getInputSyms</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../marytts/fst/AlignerTrainer.html#lexiconSize()">lexiconSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../marytts/fst/AlignerTrainer.html#readLexicon(java.io.BufferedReader, java.lang.String)">readLexicon</A></B>(java.io.BufferedReader&nbsp;lexicon,
            java.lang.String&nbsp;splitSym)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This reads a lexicon where input and output strings are separated by a
 delimiter that can be specified (splitSym).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../marytts/fst/AlignerTrainer.html#splitAndAdd(java.lang.String, java.lang.String)">splitAndAdd</A></B>(java.lang.String&nbsp;inStr,
            java.lang.String&nbsp;outStr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This adds the input and output string in the most simple way: symbols
 are simply the characters of the strings - no phonemisation/syllabification
 or whatsoever is performed.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="optInfo"><!-- --></A><H3>
optInfo</H3>
<PRE>
protected java.util.List&lt;java.lang.String&gt; <B>optInfo</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="inSplit"><!-- --></A><H3>
inSplit</H3>
<PRE>
protected java.util.List&lt;java.lang.String[]&gt; <B>inSplit</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="outSplit"><!-- --></A><H3>
outSplit</H3>
<PRE>
protected java.util.List&lt;java.lang.String[]&gt; <B>outSplit</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="graphemeSet"><!-- --></A><H3>
graphemeSet</H3>
<PRE>
protected java.util.Set&lt;java.lang.String&gt; <B>graphemeSet</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="logger"><!-- --></A><H3>
logger</H3>
<PRE>
protected org.apache.log4j.Logger <B>logger</B></PRE>
<DL>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="AlignerTrainer(boolean, boolean)"><!-- --></A><H3>
AlignerTrainer</H3>
<PRE>
public <B>AlignerTrainer</B>(boolean&nbsp;inIsOutAlphabet,
                      boolean&nbsp;hasOptInfo)</PRE>
<DL>
<DL>
<DT><B>Parameters:</B><DD><CODE>inIsOutAlphabet</CODE> - boolean indicating as input and output strings
 should be considered as belonging to the same symbol sets (alignment
 between identical symbol is then cost-free)</DL>
</DL>
<HR>

<A NAME="AlignerTrainer()"><!-- --></A><H3>
AlignerTrainer</H3>
<PRE>
public <B>AlignerTrainer</B>()</PRE>
<DL>
<DD>New AlignerTrainer for pairs of different symbol sets with no optional info.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="readLexicon(java.io.BufferedReader, java.lang.String)"><!-- --></A><H3>
readLexicon</H3>
<PRE>
public void <B>readLexicon</B>(java.io.BufferedReader&nbsp;lexicon,
                        java.lang.String&nbsp;splitSym)
                 throws java.io.IOException</PRE>
<DL>
<DD>This reads a lexicon where input and output strings are separated by a
 delimiter that can be specified (splitSym). Strings are taken as they are
 no normalization (eg. stress/syllable symbol removal, lower-casing ...)
 is performed; if space characters are present in the output string, it is used as a 
 separator. In a third row additional info (eg. part of speech) can be
 given.
 Strings are stored split into symbols.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>lexicon</CODE> - reader for lexicon<DD><CODE>splitSym</CODE> - symbol to split columns of lexicon<DD><CODE>hasOptInfo</CODE> - whether the lexicon has optional info in a third column
 eg. POS
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="splitAndAdd(java.lang.String, java.lang.String)"><!-- --></A><H3>
splitAndAdd</H3>
<PRE>
public void <B>splitAndAdd</B>(java.lang.String&nbsp;inStr,
                        java.lang.String&nbsp;outStr)</PRE>
<DL>
<DD>This adds the input and output string in the most simple way: symbols
 are simply the characters of the strings - no phonemisation/syllabification
 or whatsoever is performed. If outStr contains space characters, it is used as a separator
 for splitting.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>inString</CODE> - <DD><CODE>outString</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="addAlreadySplit(java.util.List, java.util.List)"><!-- --></A><H3>
addAlreadySplit</H3>
<PRE>
public void <B>addAlreadySplit</B>(java.util.List&lt;java.lang.String&gt;&nbsp;inStr,
                            java.util.List&lt;java.lang.String&gt;&nbsp;outStr)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addAlreadySplit(java.lang.String[], java.lang.String[])"><!-- --></A><H3>
addAlreadySplit</H3>
<PRE>
public void <B>addAlreadySplit</B>(java.lang.String[]&nbsp;inStr,
                            java.lang.String[]&nbsp;outStr)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addAlreadySplit(java.util.List, java.util.List, java.lang.String)"><!-- --></A><H3>
addAlreadySplit</H3>
<PRE>
public void <B>addAlreadySplit</B>(java.util.List&lt;java.lang.String&gt;&nbsp;inStr,
                            java.util.List&lt;java.lang.String&gt;&nbsp;outStr,
                            java.lang.String&nbsp;optionalInfo)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addAlreadySplit(java.lang.String[], java.lang.String[], java.lang.String)"><!-- --></A><H3>
addAlreadySplit</H3>
<PRE>
public void <B>addAlreadySplit</B>(java.lang.String[]&nbsp;inStr,
                            java.lang.String[]&nbsp;outStr,
                            java.lang.String&nbsp;optionalInfo)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="alignIteration()"><!-- --></A><H3>
alignIteration</H3>
<PRE>
public void <B>alignIteration</B>()</PRE>
<DL>
<DD>One iteration of alignment, using adapted Levenshtein distance.
 After the iteration, the costs between a grapheme and a phone are
 set by the log probability of the phone given the grapheme. Analogously,
 The deletion cost is set by the log of deletion probability.
 In the first iteration, all operations cost maxCost.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lexiconSize()"><!-- --></A><H3>
lexiconSize</H3>
<PRE>
public int <B>lexiconSize</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getAlignment(int)"><!-- --></A><H3>
getAlignment</H3>
<PRE>
public <A HREF="../../marytts/fst/StringPair.html" title="class in marytts.fst">StringPair</A>[] <B>getAlignment</B>(int&nbsp;entryNr)</PRE>
<DL>
<DD>gets an alignment of the graphemes to the phones of an entry.
 a StringPair array is returned, where every entry contains a grapheme
 together with the phone sequence it is mapped to. The phone String is
 just the concatenation of the symbols in the aligned sequence.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>entryNr</CODE> - nr of the lexicon entry</DL>
</DD>
</DL>
<HR>

<A NAME="getAlignmentString(int)"><!-- --></A><H3>
getAlignmentString</H3>
<PRE>
public java.lang.String[] <B>getAlignmentString</B>(int&nbsp;entryNr)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getInfoAlignment(int)"><!-- --></A><H3>
getInfoAlignment</H3>
<PRE>
public <A HREF="../../marytts/fst/StringPair.html" title="class in marytts.fst">StringPair</A>[] <B>getInfoAlignment</B>(int&nbsp;entryNr)</PRE>
<DL>
<DD>gets an alignment of the graphemes to the phones of an entry.
 a StringPair array is returned, where every entry contains a grapheme
 together with the phone sequence it is mapped to. The phone String is
 just the concatenation of the symbols in the aligned sequence.
 In addition, the extra info (eg. POS) is appended as one symbol on the
 input side.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>entryNr</CODE> - nr of the lexicon entry</DL>
</DD>
</DL>
<HR>

<A NAME="getInputSyms()"><!-- --></A><H3>
getInputSyms</H3>
<PRE>
public java.util.Set&lt;java.lang.String&gt; <B>getInputSyms</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="align(java.lang.String[], java.lang.String[])"><!-- --></A><H3>
align</H3>
<PRE>
public int[] <B>align</B>(java.lang.String[]&nbsp;istr,
                   java.lang.String[]&nbsp;ostr)</PRE>
<DL>
<DD>This computes the alignment that has the lowest distance between two
 Strings.

 There are three differences to the normal Levenshtein-distance:

 1. Only insertions and deletions are allowed, no replacements (i.e. no
    "diagonal" transitions)
 2. insertion costs are dependent on a particular phone on the input side
    (the one they are aligned to)
 3. deletion is equivalent to a symbol on the input side that is not
    aligned. There are costs associated with that.

 The method returns for each input symbol the indix of the right alignment
 boundary. eg. for input ['a','b'] and output ['a','a','b'] a correct
 alignment would be: [2,3]
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>in</CODE> - <DD><CODE>out</CODE> - 
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/AlignerTrainer.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../marytts/fst/FST.html" title="class in marytts.fst"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?marytts/fst/AlignerTrainer.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="AlignerTrainer.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
